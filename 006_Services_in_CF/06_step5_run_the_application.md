### Step 5: Running the application

Before running the application locally and in Cloud Foundry, let's add a starter for Spring Boot Actuator. It will enable us to monitor Spring MVC applications via HTTP endpoints. We will use its `/health` endpoint to see the  health information about the application and the database it uses. Add this dependency to the `pom.xml` file to use the Actuator in your application:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```



#### Configuring the application to run locally with the H2 database

To run the application locally, we are going to use the H2 in-memory database. There is no need to provide any connection URLs: Spring Boot can configure embedded H2, SQL, and Derby databases automatically. We will just add a build dependency for H2 in the `pom.xml` file:

```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
</dependency>
```

> **NOTE:** In general, you need a dependency on `spring-jdbc` for an embedded database to be auto-configured. In our example, it is pulled in transitively via `spring-boot-starter-data-jpa`, so you don’t need to add `spring-jdbc` explicitly in your `pom.xml`.

Now we are going to build and run our ‘HelloWorld’ application:

	$ mvn clean package
	$ java -jar target/{{cf apps | grep started | awk '{print $1}'}}-0.0.1-SNAPSHOT.jar
	
The console output, besides other initialization logs, will display the Hibernate messages about using the H2 database and importing data from `import.sql`: 

	...
	2016-10-21 12:36:53.637  INFO 9336 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
	2016-10-21 12:36:54.499  INFO 9336 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export
	Hibernate: drop table person if exists
	Hibernate: create table person (id bigint generated by default as identity, first_name varchar(255), last_name varchar(255), primary key (id))
	2016-10-21 12:36:54.513  INFO 9336 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000476: Executing import script '/import.sql'
	2016-10-21 12:36:54.516  INFO 9336 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete
	...

To check on the application's health, open `[localhost:8080/health](http://localhost:8080/health)`.

```json
{
  "status": "UP",
  "diskSpace": {
    "status": "UP",
    "total": 115343355904,
    "free": 81408557056,
    "threshold": 10485760
  },
  "db": {
    "status": "UP",
    "database": "H2",
    "hello": 1
  }
}
```

Now enter `[localhost:8080](http://localhost:8080)` in your web browser to see the application's greeting message containing a person's name read from the database:

	Hello World! My name is Kim Bauer.
	
> **NOTE:** Please mind that our application picks a random person name from the database. In your case, it can be any other name from the database.


#### Configuring the application to run in Cloud Foundry with the MySQL service

Finally, we are going to enable our application to use the MySQL bound service when running in CF.

To separate the application configuration for local and cloud environments, we are going to use Spring Profiles. When running locally, the `default` profile is activated implicitly if no other profile is specified. In this case, the application is configured with the Spring Boot using the default properties file `application.yml`. When running in the cloud, the `cloud` profile has to be explicitly specified in `manifest.yml`. For additional 'cloud' configuration, create an `application-cloud.yml` config:

```yml
---
spring:
  jpa:
    database-platform: org.hibernate.dialect.MySQLDialect
  datasource:
    driverClassName: com.mysql.jdbc.Driver
```

Here we configure Hibernate JPA to use `MySQLDialect` and provide Spring `datasource` configuration. The values for the `datasource.*` properties are set using `VCAP_*` environment variables as per [12-factor app](https://12factor.net/config).

>**NOTE:** When binding a service to an application, a set of environment properties get injected into the application under the key `VCAP_SERVICES`. Run `cf env APP` to see them:
>
>		$ cf env helloworld
>		
>		"VCAP_SERVICES": {
>		 "mysql": [
>		  {
>		   "credentials": {
>		    "database": "d797ce5ffe7f242c8b235da6a98205987",
>		    "host": "mysql-int.mysql.svc",
>		    "hostname": "mysql-int.mysql.svc",
>		    "password": "vfzWbDxxHTXCGNHffrsomSZY1hGhA833AE7EPWnMllQ",
>		    "port": "3306",
>		    "user": "094671a8773db975",
>		    "username": "094671a8773db975"
>		   },
>		   "label": "mysql",
>		   "name": "example-mysql",
>		   "plan": "default",
>		   "provider": null,
>		   "syslog_drain_url": null,
>		   "tags": [
>		    "mysql"
>		   ],
>		   "volume_mounts": []
>		  }
>		 ]
>		}
>
> To make consumption of the raw JSON a little less clumsy, Spring Boot automatically converts this data into a flat set of properties similar to this:
>
>		...
>		"vcap.services.example-mysql.name": "example-mysql",
>		"vcap.services.example-mysql.plan": "default",
>		"vcap.services.example-mysql.tags": "mysql",
>		"vcap.services.example-mysql.label": "mysql",
>		...

At last, we need to add JDBC Driver for MySQL. Open your `pom.xml` and add this dependency:

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

Now, we are ready to run our application. Build the application and push it to Cloud Foundry:

	$ mvn clean package
	$ cf push
	
	requested state: started
	instances: 1/1
	usage: 512M x 1 instances
	urls: helloworld.[cloud-foundry].com
	last uploaded: Fri Oct 21 15:28:34 UTC 2016
	stack: cflinuxfs2
	buildpack: https://github.com/cloudfoundry/java-buildpack.git

	     state     since                    cpu    memory           disk           details
	#0   running   2016-10-21 06:29:19 PM   0.0%   327.5M of 512M   150.8M of 1G
	
Now, open the page

    http://{{cf apps | grep started | awk '{print $1}'}}.{{echo $CF_DOMAIN}}/health
    
to check the health of your application. The output should be similar to

```json
{
  "status": "UP",
  "diskSpace": {
    "status": "UP",
    "total": 1056858112,
    "free": 898740224,
    "threshold": 10485760
  },
  "db": {
    "status": "UP",
    "database": "MySQL",
    "hello": 1
  }
}
```

Now the application is pulling data from the MySQL database.

Type in your browser: 

    http://{{cf apps | grep started | awk '{print $1}'}}.{{echo $CF_DOMAIN}}  
    
You should see the following output:

	Hello World! My name is Kim Bauer.

> **NOTE:** You can still run the application locally despite MySQL depending on the classpath. Since, in the local environment, you run with no profile specified, `application-cloud.yml` settings are disregarded, so Spring Boot fails to configure MySQL and thus rolls back to using the H2 database.